<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>07. 지연성2</title>
        <script src="./lib/fx.js"></script>
    </head>
    <body>
        <!-- prettier-ignore -->
        ## 결과를 만드는 함수 reduce, take

        ### reduce
        <script>
            L.entries = function* (obj) {
                for (const k in obj) {
                    yield [k, obj[k]];
                }
            };

            const join = curry((sep = ',', iter) =>
                reduce((a, b) => `${a}${sep}${b}`, iter),
            );

            // join은 이터러블 프로토콜을 따르고 있으므로
            // join 함수에 가기 전에 만들어 진 값들을 지연할 수 있다(reduce는 내부적으로 next함수를 통해 값을 꺼내기 때문에)
            // map -> L.map을 써도 상관없다 (이터러블 객체를 사용하면 지연평가 가능)
            const queryStr = pipe(
                // Object.entries,
                L.entries,
                // map(([k, v]) => `${k}=${v}`),
                L.map(([k, v]) => `${k}=${v}`),
                join('&'),
            );

            log(queryStr({ limit: 10, offset: 10, type: 'notice' }));

            function* a() {
                yield 10;
                yield 11;
                yield 12;
                yield 13;
            }
            // Uncaught TypeError: a(...).join is not a function
            // log(a().join(','));

            // 10 - 11 - 12 - 13
            log(join(' - ', a()));
        </script>

        ### take, find
        <script>
            const users = [
                { age: 32 },
                { age: 31 },
                { age: 37 },
                { age: 28 },
                { age: 25 },
                { age: 32 },
                { age: 31 },
                { age: 37 },
            ];

            const find = curry((f, iter) =>
                go(iter, L.filter(f), take(1), ([a]) => a),
            );

            log(find((u) => u.age < 30)(users));

            go(
                users,
                L.map((u) => u.age),
                find((n) => n < 30),
                log,
            );
        </script>

        ## L.flatten
        <script>
            log([[1, 2], 3, 4, [5, 6], [7, 8, 9]]);

            const isIterable = (a) => a && a[Symbol.iterator];

            L.flatten = function* (iter) {
                for (const a of iter) {
                    if (isIterable(a)) {
                        // yield *iterable은 for (const val of iterable) yield val; 과 같습니다.
                        // for (const b of a) {
                        //     yield b;
                        // }
                        yield* a;
                    } else {
                        yield a;
                    }
                }
            };

            var it = L.flatten([[1, 2], 3, 4, [5, 6], [7, 8, 9]]);
            log([...it]);
            log(take(3, L.flatten([[1, 2], 3, 4, [5, 6], [7, 8, 9]])));

            const flatten = pipe(L.flatten, takeAll);
            log(flatten([[1, 2], 3, 4, [5, 6], [7, 8, 9]]));
        </script>

        ## L.deepFlat
        <script>
            /**
             * 만일 깊은 Iterable을 모두 펼치고 싶다면 아래와 같이 L.deepFlat을 구현하여 사용할 수 있습니다.
             * L.deepFlat은 깊은 Iterable을 펼쳐줍니다.
             */
            L.deepFlat = function* f(iter) {
                for (const a of iter) {
                    if (isIterable(a)) {
                        yield* f(a);
                    } else {
                        yield a;
                    }
                }
            };
            log([...L.deepFlat([1, [2, [3, 4], [[5]]]])]);
            // [1, 2, 3, 4, 5];
        </script>

        ## L.flatMap
        <script></script>
    </body>
</html>
